#include <iostream>
#include<memory>
using namespace std;

class child;

class parent
{
public:
shared_ptr<child> spchild;

parent() = default;
~parent()
{
    cout<<"destroy parent "<<endl;
}
};

class child
{
public:
shared_ptr<parent> spparent;

child() = default;
~child()
{
    cout<<"destroy child "<<endl;
}
};

int main()
{
   shared_ptr<parent> sp1 = make_shared<parent>();
   shared_ptr<child> sp2 = make_shared<child>();

   sp1->spchild = sp2;
   sp2->spparent = sp1;


    return 0;
}

What happens?

sp1 is created â†’ parent object constructed.

sp2 is created â†’ child object constructed.

sp1->spchild = sp2;

Now parent has a shared_ptr<child>.

So childâ€™s reference count = 2 (one from sp2, one from parent).

sp2->spparent = sp1;

Now child has a shared_ptr<parent>.

So parentâ€™s reference count = 2 (one from sp1, one from child).

When main() ends:

sp1 goes out of scope â†’ decreases parentâ€™s count by 1.

sp2 goes out of scope â†’ decreases childâ€™s count by 1.

But each object still has one reference left (from the other one!).

***************solution******************
#include <iostream>
#include <memory>
using namespace std;

class child;

class parent {
public:
    shared_ptr<child> spchild;  // parent owns child
    ~parent() { cout << "destroy parent" << endl; }
};

class child {
public:
    weak_ptr<parent> spparent;  // child only observes parent (no ownership)
    ~child() { cout << "destroy child" << endl; }
};

int main() {
    shared_ptr<parent> sp1 = make_shared<parent>();
    shared_ptr<child> sp2  = make_shared<child>();

    sp1->spchild = sp2;   // parent owns child
    sp2->spparent = sp1;  // child refers to parent, but does not own

    return 0;
}

Step-by-Step Lifetime

Object creation

sp1 points to a new parent.
â†’ parent's ref count = 1.

sp2 points to a new child.
â†’ child's ref count = 1.

Set relationships

sp1->spchild = sp2;

Now the parent owns the child.

child's ref count = 2 (sp2 + parent::spchild).

sp2->spparent = sp1;

Child holds a weak_ptr to parent.

ðŸ‘‰ Does NOT increase parentâ€™s count.

parent's ref count = 1 (still just sp1).

Exiting main() â†’ Destruction begins

sp1 (the shared_ptr<parent>) goes out of scope.

This decreases parentâ€™s ref count: 1 â†’ 0.

Since itâ€™s now 0, the parent object is destroyed.
â†’ prints "destroy parent".

During parent destruction

parentâ€™s destructor runs.

Its member spchild (a shared_ptr<child>) is destroyed automatically.

That decreases childâ€™s ref count: 2 â†’ 1.

Remaining owner of child = sp2 in main().

Then sp2 goes out of scope

This decreases childâ€™s ref count: 1 â†’ 0.

Since count = 0, the child object is destroyed.
â†’ prints "destroy child".


Final Output
destroy parent
destroy child


âœ… So the correct sequence is:

parent destroyed first (when sp1 dies).

Then child destroyed (when sp2 dies).



