#include <iostream>
#include <vector>
#include <memory>  // Needed for shared_ptr and make_shared
using namespace std;

int main() {
    // ğŸ”¹ Creating shared_ptr (NOT recommended way)
    shared_ptr<int> sp1(new int);  // Allocates:
                                   // 1. memory for int
                                   // 2. control block for reference count

    // ğŸ”¹ Recommended: use make_shared (fast + exception-safe)
    shared_ptr<int> sp2 = make_shared<int>(25);

Case 1 â€” shared_ptr<int> sp1(new int);

Two separate allocations happen:

new int â†’ allocates memory for the int.

shared_ptr must also allocate a control block (reference count, deleter info, etc).

So there are two allocations on the heap.

Case 2 â€” make_shared<int>(25);

Does only one allocation:

Allocates memory for both the int value and the control block together in one chunk.

So itâ€™s faster and more memory-efficient.

When NOT to use make_shared

If you need a custom deleter, because make_shared doesnâ€™t let you specify one.

If you want separate lifetimes for the control block and the object (rare, advanced use cases).

    // ğŸ”¹ Get reference count
    cout << "ref count is " << sp2.use_count() << endl;

    // ğŸ”¹ Get the raw pointer
    int* RawPtr = sp2.get();
    cout << "value using the raw pointer: " << *RawPtr << endl;

    // âŒ BAD PRACTICE: constructing two shared_ptr from same raw pointer
    // This causes double delete and undefined behavior
    /*
    int* p = new int;
    shared_ptr<int> sp3(p);
    shared_ptr<int> sp4(p);  // âŒ Wrong: both will try to delete same pointer
    */

    // âŒ Invalid syntax: constructor is explicit
    // shared_ptr<int> sp3 = new int;  // âŒ Build error

    // ğŸ”¹ Shared_ptr with array: use custom deleter
    {
        shared_ptr<int> sp(new int[10], [](int* p) {
            cout << "Custom deleter for array called!" << endl;
            delete[] p;
        });

        // You can now use sp just like any shared_ptr
    } // sp goes out of scope here, and custom deleter is called

    return 0;
}

âœ… 1. Custom Deletion Using a Function Pointer
void deleter(int* x) {
    std::cout << "DELETER FUNCTION CALLED\n";
    delete[] x;
}

int main() {
    shared_ptr<int> p(new int[5], deleter);
    // custom deleter will be called when p goes out of scope
}
Notes:
deleter must match the type: void (*)(int*).

It will be called when the shared_ptr's reference count hits zero.

Used when the deletion logic is shared or reusable.

2. Custom Deletion Using a Lambda Function
shared_ptr<int> p(new int[5], [](int* p) {
    std::cout << "I am using custom deletor" << std::endl;
    delete[] p;
});
Notes:
Lambdas are more flexible and inline.

Especially useful for one-off deletions.

Cleaner when no named function is needed.
