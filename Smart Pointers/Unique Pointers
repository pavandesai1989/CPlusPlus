1. Overview of std::unique_ptr

std::unique_ptr is a smart pointer introduced in C++11.

It owns a dynamically allocated object exclusively — only one unique_ptr can own a particular resource at a time.

It automatically deletes the object it owns when it goes out of scope (RAII).

Unlike shared_ptr, unique_ptr cannot be copied, only moved.

It can manage single objects or arrays.

2. Declaration / Types
#include <memory>

std::unique_ptr<int> ptr1;            // Empty unique_ptr
std::unique_ptr<int> ptr2(new int(10)); // Owns an int initialized to 10
std::unique_ptr<int[]> arr(new int[5]); // Unique_ptr to array


Key points:

unique_ptr<T> → single object

unique_ptr<T[]> → array (needs delete[] internally)

Must not mix unique_ptr<T> with arrays.

3. Constructors
C++11 Constructors

Default constructor

std::unique_ptr<int> p;  // p.get() == nullptr


Pointer constructor

std::unique_ptr<int> p(new int(5));


Move constructor

std::unique_ptr<int> p1(new int(10));
std::unique_ptr<int> p2(std::move(p1));  // ownership moved


Constructor with deleter

auto deleter = [](int* p){ delete p; };
std::unique_ptr<int, decltype(deleter)> p(new int(20), deleter);

4. Destructor

Automatically deletes the managed object using the deleter.

{
    std::unique_ptr<int> p(new int(5)); // object allocated
} // p goes out of scope → int deleted automatically


5. Assignment Operators

Move assignment

std::unique_ptr<int> p1(new int(10));
std::unique_ptr<int> p2;
p2 = std::move(p1);  // ownership transferred


Deleted copy assignment

std::unique_ptr<int> p1(new int(5));
std::unique_ptr<int> p2;
p2 = p1;  // ERROR! unique_ptr cannot be copied


6. Member Functions

Here’s a complete list:

Function	Description	Example
get()	Returns raw pointer without releasing ownership	int* raw = p.get();
release()	Releases ownership and returns pointer (caller must delete)	int* raw = p.release();
reset()	Deletes the managed object (if any) and takes new pointer	p.reset(new int(5));
swap()	Swaps ownership with another unique_ptr	p1.swap(p2);
operator*()	Dereference operator	int val = *p;
operator->()	Member access operator	p->member = value;
operator bool()	Checks if the pointer is non-null	if(p) {...}


6.1 get()

Returns the raw pointer, does not release ownership.

std::unique_ptr<int> p(new int(5));
int* raw = p.get();
std::cout << *raw << std::endl; // prints 5

6.2 release()

Releases ownership, returns the raw pointer.

After release, the unique_ptr becomes empty.

std::unique_ptr<int> p(new int(5));
int* raw = p.release();
if(!p) std::cout << "p is empty\n";
delete raw; // manual delete required

6.3 reset()

Deletes current object and optionally takes a new pointer.

std::unique_ptr<int> p(new int(10));
p.reset(new int(20)); // old object deleted, p now owns 20
p.reset();            // deletes object, p becomes nullptr

6.4 swap()

Exchanges ownership between two unique_ptrs.

std::unique_ptr<int> p1(new int(5));
std::unique_ptr<int> p2(new int(10));
p1.swap(p2);

6.5 Dereference operators

Works like raw pointers:

std::unique_ptr<int> p(new int(10));
std::cout << *p << std::endl; // 10

struct Test { int x; };
std::unique_ptr<Test> t(new Test{42});
std::cout << t->x << std::endl; // 42

6.6 operator bool

Checks if pointer is non-null:

std::unique_ptr<int> p(new int(5));
if(p) std::cout << "p is valid\n";

7. Special Features in C++14

C++14 introduced helper functions for unique_ptr:

std::make_unique

Safer way to create unique_ptr (avoids new directly)

Provides exception safety.

auto p = std::make_unique<int>(10);        // single object
auto arr = std::make_unique<int[]>(5);     // array of 5 ints


C++11 does not have make_unique. You have to use new manually.

Support for std::unique_ptr<T[]>

Can now safely manage arrays and use operator[].

auto arr = std::make_unique<int[]>(3);
arr[0] = 1; arr[1] = 2; arr[2] = 3;

8. Notes / Best Practices

Always prefer make_unique (C++14) over new.

unique_ptr is non-copyable, but movable.

Use release() carefully — you’re responsible for deleting the pointer.

Can be used with custom deleters.

Can manage arrays with unique_ptr<T[]>.

9. Example Code (C++14)
#include <iostream>
#include <memory>
using namespace std;

struct Test {
    int x;
    Test(int val):x(val){}
    ~Test(){cout<<"Test destroyed\n";}
};

int main() {
    auto p1 = make_unique<Test>(42);      // C++14
    cout << p1->x << endl;

    unique_ptr<Test> p2(new Test(10));    // C++11 style
    p2.reset();                            // delete old object

    unique_ptr<int> p3(new int(5));
    int* raw = p3.release();              // release ownership
    delete raw;

    auto arr = make_unique<int[]>(3);
    arr[0] = 10; arr[1] = 20; arr[2] = 30;

    return 0;
}


Output:

42
Test destroyed
Test destroyed


✅ Summary Table: Key Differences C++11 vs C++14

Feature	C++11	C++14
make_unique	❌ not available	✅ available
Arrays	✅ (with unique_ptr<T[]>)	✅ improved support
Move semantics	✅	✅
Custom deleters	✅	✅
Thread safety	✅ (for single pointer)	✅


