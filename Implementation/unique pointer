******interview ready***

#include <iostream>
#include <utility>   // for std::move

// UniquePtr class template
template<typename T>
class UniquePtr {
public:
    // Constructor
    explicit UniquePtr(T* ptr = nullptr) noexcept : m_ptr(ptr) {}

    // Destructor
    ~UniquePtr() {
        delete m_ptr;
    }

    // Delete copy operations (non-copyable)
    UniquePtr(const UniquePtr&) = delete;
    UniquePtr& operator=(const UniquePtr&) = delete;

    // Move constructor
    UniquePtr(UniquePtr&& other) noexcept : m_ptr(other.m_ptr) {
        other.m_ptr = nullptr;
    }

    // Move assignment
    UniquePtr& operator=(UniquePtr&& other) noexcept {
        if (this != &other) {
            reset(); // delete current
            m_ptr = other.m_ptr;
            other.m_ptr = nullptr;
        }
        return *this;
    }

    // Dereference operator
    T& operator*() const {
        return *m_ptr;
    }

    // Arrow operator
    T* operator->() const {
        return m_ptr;
    }

    // Access raw pointer
    T* get() const noexcept {
        return m_ptr;
    }

    // Release ownership
    T* release() noexcept {
        T* temp = m_ptr;
        m_ptr = nullptr;
        return temp;
    }

    // Reset with new pointer
    void reset(T* ptr = nullptr) noexcept {
        if (m_ptr != ptr) {
            delete m_ptr;
            m_ptr = ptr;
        }
    }

    // Check if not null
    explicit operator bool() const noexcept {
        return m_ptr != nullptr;
    }

private:
    T* m_ptr = nullptr;
};

struct MyClass {
    void greet() {
        std::cout << "Hello from MyClass!\n";
    }
};

int main() {
    UniquePtr<MyClass> up1(new MyClass());

    if (up1) {
        up1->greet();
    }

    UniquePtr<MyClass> up2 = std::move(up1);
    if (!up1) {
        std::cout << "up1 is now empty.\n";
    }

    up2->greet();

    up2.reset(new MyClass());
    up2->greet();

    MyClass* rawPtr = up2.release();
    if (!up2) {
        std::cout << "up2 is now empty after release.\n";
    }

    delete rawPtr; // manual cleanup
    return 0;
}

