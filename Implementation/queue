STL queue uses deque internally and u can use list as well.


**********ararys*****
#include<iostream>
using namespace std;


class myqueue
{
private:
int* arr;
int front;
int rear;
int currsize;
int maxsize;


public:
myqueue()
{
    maxsize = 100;
    front = -1;
    rear = -1;
    currsize = 0;
    arr = new int[maxsize];
}

void push(int val)
{
    //when we cant push 
    if(currsize == maxsize)
    {
        cout<<"full "<<endl;
        return;
    }

    if(front == -1 && rear == -1)
    {
        front = 0;
        rear = 0;
    }
    else
    {
        rear = (rear+1)%maxsize;
    }

    arr[rear] = val;
    currsize++;
}

int pop()
{
    //when cant pop. when empty
    if(front == -1)
    {
        cout<<"empty"<<endl;
        return -1;
    }

    int ele = arr[front];
    if(currsize == 1)
    {
        front = -1;
        rear = -1;
    }
    else
    {
        //move start
        front = (front+1)%maxsize;
    }
    currsize--;
    return ele;
}

int top()
{
    if(front == -1)
    {
        cout<<"empty"<<endl;
        return -1;
    }
    return arr[front];
}

int size()
{
    return currsize;
}



};



int main() {
  myqueue q;
  q.push(4);
  q.push(14);
  q.push(24);
  q.push(34);
  cout << "The peek of the queue before deleting any element " << q.top() << endl;
  cout << "The size of the queue before deletion " << q.size() << endl;
  cout << "The first element to be deleted " << q.pop() << endl;
  cout << "The peek of the queue after deleting an element " << q.top() << endl;
  cout << "The size of the queue after deleting an element " << q.size() << endl;

  return 0;
}


***********generic container*****
#include <iostream>
#include <deque>
#include <list>

template<typename T, typename Container = std::deque<T>>
class MyQueue {
private:
    Container c;

public:
    void push(const T& val) {
        c.push_back(val);
    }

    void pop() {
        if (!c.empty())
            c.pop_front();
    }

    T& front() {
        return c.front();
    }

    const T& front() const {
        return c.front();
    }

    T& back() {
        return c.back();
    }

    const T& back() const {
        return c.back();
    }

    bool empty() const {
        return c.empty();
    }

    size_t size() const {
        return c.size();
    }

    void emplace(const T& val) {
        c.emplace_back(val);
    }

    void swap(MyQueue& other) {
        c.swap(other.c);
    }
};
int main() {
    // Using default (deque)
    MyQueue<int> q1;
    q1.push(10);
    q1.push(20);
    std::cout << "Deque Front: " << q1.front() << ", Back: " << q1.back() << '\n';

    // Using list
    MyQueue<int, std::list<int>> q2;
    q2.push(100);
    q2.push(200);
    std::cout << "List Front: " << q2.front() << ", Back: " << q2.back() << '\n';

    // Swap example
    q1.swap(q1);
}



**********Link list***********

#include <iostream>
#include <stdexcept>

template <typename T>
class MyQueue {
private:
    struct Node {
        T data;
        Node* next;
        Node(const T& val) : data(val), next(nullptr) {}
    };

    Node* frontNode;
    Node* backNode;
    size_t count;

public:
    MyQueue() : frontNode(nullptr), backNode(nullptr), count(0) {}

    ~MyQueue() {
        while (!empty()) {
            pop();
        }
    }

    void push(const T& val) {
        Node* node = new Node(val);
        if (backNode) {
            backNode->next = node;
        } else {
            frontNode = node;
        }
        backNode = node;
        ++count;
    }

    void pop() {
        if (empty()) throw std::runtime_error("Queue is empty");
        Node* temp = frontNode;
        frontNode = frontNode->next;
        if (!frontNode) backNode = nullptr;
        delete temp;
        --count;
    }

    T& front() {
        if (empty()) throw std::runtime_error("Queue is empty");
        return frontNode->data;
    }

    T& back() {
        if (empty()) throw std::runtime_error("Queue is empty");
        return backNode->data;
    }

    bool empty() const {
        return count == 0;
    }

    size_t size() const {
        return count;
    }
};

int main() {
    MyQueue<int> q;
    q.push(10);
    q.push(20);
    q.push(30);

    std::cout << "Front: " << q.front() << std::endl; // 10
    std::cout << "Back: " << q.back() << std::endl;   // 30

    q.pop();
    std::cout << "After pop, Front: " << q.front() << std::endl; // 20

    std::cout << "Size: " << q.size() << std::endl;  // 2
    std::cout << "Empty? " << std::boolalpha << q.empty() << std::endl;

    return 0;
}

