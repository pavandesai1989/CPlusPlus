STL queue uses deque internally and u can use list as well.


**********ararys*****
#include <iostream>
using namespace std;

class myqueue {
private:
    int* arr;
    int front;
    int rear;
    int currsize;
    int maxsize;

public:
    myqueue(int size = 100) {
        maxsize = size;
        front = -1;
        rear = -1;
        currsize = 0;
        arr = new int[maxsize];
    }

    ~myqueue() {
        delete[] arr;
    }

    myqueue(const myqueue&) = delete;
    myqueue& operator=(const myqueue&) = delete;

    void push(int val) {
        if (currsize == maxsize) {
            cerr << "Queue is full" << endl;
            return;
        }

        if (front == -1 && rear == -1) {
            front = rear = 0;
        } else {
            rear = (rear + 1) % maxsize;
        }

        arr[rear] = val;
        currsize++;
    }

    int pop() {
        if (front == -1) {
            cerr << "Queue is empty" << endl;
            return -1;
        }

        int ele = arr[front];
        if (currsize == 1) {
            front = rear = -1;
        } else {
            front = (front + 1) % maxsize;
        }

        currsize--;
        return ele;
    }

    int top() const {
        if (front == -1) {
            cerr << "Queue is empty" << endl;
            return -1;
        }
        return arr[front];
    }

    int getSize() const {
        return currsize;
    }

    bool isEmpty() const {
        return currsize == 0;
    }

    bool isFull() const {
        return currsize == maxsize;
    }
};

int main() {
    myqueue q;
    q.push(4);
    q.push(14);
    q.push(24);
    q.push(34);
    cout << "The peek of the queue before deleting any element: " << q.top() << endl;
    cout << "The size of the queue before deletion: " << q.getSize() << endl;
    cout << "The first element to be deleted: " << q.pop() << endl;
    cout << "The peek of the queue after deleting an element: " << q.top() << endl;
    cout << "The size of the queue after deleting an element: " << q.getSize() << endl;

    return 0;
}



***********generic container*****
#include <iostream>
#include <deque>
#include <list>

template<typename T, typename Container = std::deque<T>>
class MyQueue {
private:
    Container c;

public:
    void push(const T& val) {
        c.push_back(val);
    }

    void pop() {
        if (!c.empty())
            c.pop_front();
    }

    T& front() {
        return c.front();
    }

    const T& front() const {
        return c.front();
    }

    T& back() {
        return c.back();
    }

    const T& back() const {
        return c.back();
    }

    bool empty() const {
        return c.empty();
    }

    size_t size() const {
        return c.size();
    }

    void emplace(const T& val) {
        c.emplace_back(val);
    }

    void swap(MyQueue& other) {
        c.swap(other.c);
    }
};
int main() {
    // Using default (deque)
    MyQueue<int> q1;
    q1.push(10);
    q1.push(20);
    std::cout << "Deque Front: " << q1.front() << ", Back: " << q1.back() << '\n';

    // Using list
    MyQueue<int, std::list<int>> q2;
    q2.push(100);
    q2.push(200);
    std::cout << "List Front: " << q2.front() << ", Back: " << q2.back() << '\n';

    // Swap example
    q1.swap(q1);
}



**********Link list***********

#include <iostream>
#include <stdexcept>

template <typename T>
class MyQueue {
private:
    struct Node {
        T data;
        Node* next;
        Node(const T& val) : data(val), next(nullptr) {}
    };

    Node* frontNode;
    Node* backNode;
    size_t count;

public:
    MyQueue() : frontNode(nullptr), backNode(nullptr), count(0) {}

    ~MyQueue() {
        while (!empty()) {
            pop();
        }
    }

    void push(const T& val) {
        Node* node = new Node(val);
        if (backNode) {
            backNode->next = node;
        } else {
            frontNode = node;
        }
        backNode = node;
        ++count;
    }

    void pop() {
        if (empty()) throw std::runtime_error("Queue is empty");
        Node* temp = frontNode;
        frontNode = frontNode->next;
        if (!frontNode) backNode = nullptr;
        delete temp;
        --count;
    }

    T& front() {
        if (empty()) throw std::runtime_error("Queue is empty");
        return frontNode->data;
    }

    T& back() {
        if (empty()) throw std::runtime_error("Queue is empty");
        return backNode->data;
    }

    bool empty() const {
        return count == 0;
    }

    size_t size() const {
        return count;
    }
};

int main() {
    MyQueue<int> q;
    q.push(10);
    q.push(20);
    q.push(30);

    std::cout << "Front: " << q.front() << std::endl; // 10
    std::cout << "Back: " << q.back() << std::endl;   // 30

    q.pop();
    std::cout << "After pop, Front: " << q.front() << std::endl; // 20

    std::cout << "Size: " << q.size() << std::endl;  // 2
    std::cout << "Empty? " << std::boolalpha << q.empty() << std::endl;

    return 0;
}

