***inter ready****

Reference counting via a control block

Rule of 5 (copyable and movable)

Safe memory management

Const correctness

Exception-safe reset, release, use_count, et

*********notes on impl***
1. ref_count is a pointer (int*)
Why? So that all copies of SharedPtr share and update the same counter.
If ref_count was just int, each copy would have its own counter → leads to double delete or memory leaks.

 2. release() is called in copy/move assignment and destructor
Why? To decrement the reference count and delete the resource when no more owners exist.

Prevents memory leaks and ensures safe cleanup.

3. No new allocation in copy constructor
SharedPtr(const SharedPtr& other)

Why? Because SharedPtr is meant to share ownership, not clone the object.

Creating a new object would break sharing semantics and lead to inconsistencies.

4. No increment in move constructor or move assignment
SharedPtr(SharedPtr&& other)

Why? Because ownership is transferred, not shared.

The original other is nullified, so the reference count remains unchanged.

5. release() is called before move assignment takes ownership
Why? If the current object already holds a resource, it needs to clean up before taking ownership of a new one.

Avoids memory leaks or orphaned pointers

 6. reset() safely replaces the owned resource
Why? reset() first releases the existing object (if any), then sets a new one with ref count 1.

This allows manual control over the lifetime of the pointer.

7.Null safety for ref_count
Why? Avoids dereferencing a null pointer when copying or deleting a null-initialized SharedPtr.

| Member       | Type   | Purpose                                                                            |
| ------------ | ------ | ---------------------------------------------------------------------------------- |
| `m_ptr`      | `T*`   | Pointer to the actual object (of type `T`) that you're managing                    |
| `m_refCount` | `int*` | Pointer to a heap-allocated counter tracking how many `SharedPtr`s share ownership |

Why do we increment *m_refCount?
Because:

We are creating a new copy of the SharedPtr (say p2) from an existing one (say p1)

Both p1 and p2 now point to the same object

So we need to increase the reference count to say:

"Now there are 2 owners of this object"

Otherwise, when one goes out of scope, it will delete the object even though the other still owns it — ❌ wrong behavior.

**** why release in copy assign***
SharedPtr<int> p1(new int(10));  // owns object A
SharedPtr<int> p2(new int(20));  // owns object B

p1 = p2;  // Copy assignment

Without release():
p1 already owns object A

You overwrite m_ptr with p2's object B

But object A is now lost — nothing is managing it

✅ Memory leak — object A was never deleted!

With release():
p1 first decrements the reference count for object A

If that was the last owner → object A is deleted

Now, p1 takes ownership of p2's object B

The reference count of object B is incremented



*************************


#include <iostream>

template<typename T>
class SharedPtr {
private:
    T* m_ptr;
    int* m_refCount;

    void release() {
        if (m_refCount) {
            (*m_refCount)--;
            if (*m_refCount == 0) {
                delete m_ptr;
                delete m_refCount;
                std::cout << "Resource deleted\n";
            }
        }
    }

public:
    // Default constructor
    SharedPtr() : m_ptr(nullptr), m_refCount(nullptr) {}

    // Parameterized constructor
    explicit SharedPtr(T* ptr) : m_ptr(ptr), m_refCount(new int(1)) {}

    // Copy constructor
    SharedPtr(const SharedPtr& other) : m_ptr(other.m_ptr), m_refCount(other.m_refCount) {
        if (m_refCount) {
            ++(*m_refCount);
        }
    }

    // Copy assignment
    SharedPtr& operator=(const SharedPtr& other) {
        if (this != &other) {
            release();
            m_ptr = other.m_ptr;
            m_refCount = other.m_refCount;
            if (m_refCount) {
                ++(*m_refCount);
            }
        }
        return *this;
    }

    // Move constructor
    SharedPtr(SharedPtr&& other) noexcept : m_ptr(other.m_ptr), m_refCount(other.m_refCount) {
        other.m_ptr = nullptr;
        other.m_refCount = nullptr;
    }

    // Move assignment
    SharedPtr& operator=(SharedPtr&& other) noexcept {
        if (this != &other) {
            release();
            m_ptr = other.m_ptr;
            m_refCount = other.m_refCount;
            other.m_ptr = nullptr;
            other.m_refCount = nullptr;
        }
        return *this;
    }

    // Destructor
    ~SharedPtr() {
        release();
    }

    // Get raw pointer
    T* get() const {
        return m_ptr;
    }

    // Dereference operators
    T& operator*() const {
        return *m_ptr;
    }

    T* operator->() const {
        return m_ptr;
    }

    // Use count
    int use_count() const {
        return m_refCount ? *m_refCount : 0;
    }

    // Reset
    void reset(T* ptr = nullptr) {
        release();
        if (ptr) {
            m_ptr = ptr;
            m_refCount = new int(1);
        } else {
            m_ptr = nullptr;
            m_refCount = nullptr;
        }
    }

    // Bool conversion
    explicit operator bool() const {
        return m_ptr != nullptr;
    }
};


struct Test {
    Test(int x) : val(x) {
        std::cout << "Test created\n";
    }
    ~Test() {
        std::cout << "Test destroyed\n";
    }
    int val;
    void show() {
        std::cout << "Value: " << val << "\n";
    }
};

int main() {
    SharedPtr<Test> p1(new Test(100));
    std::cout << "p1 use_count: " << p1.use_count() << "\n";

    {
        SharedPtr<Test> p2 = p1;
        std::cout << "p2 use_count: " << p2.use_count() << "\n";
        p2->show();
    } // p2 goes out of scope

    std::cout << "p1 use_count after p2: " << p1.use_count() << "\n";

    p1.reset();
    std::cout << "p1 use_count after reset: " << p1.use_count() << "\n";

    return 0;
}

Test created
p1 use_count: 1
p2 use_count: 2
Value: 100
Test destroyed
Resource deleted
p1 use_count after p2: 1
Test destroyed
Resource deleted
p1 use_count after reset: 0

Common Follow-up Questions
What's the difference between shared_ptr and unique_ptr?

What are circular references and how to avoid them?

How would you implement weak_ptr?

Can SharedPtr be made thread-safe?

Why use a separate control block in real-world implementations?
