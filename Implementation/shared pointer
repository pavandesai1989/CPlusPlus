***inter ready****

Reference counting via a control block

Rule of 5 (copyable and movable)

Safe memory management

Const correctness

Exception-safe reset, release, use_count, et


#include <iostream>

template<typename T>
class SharedPtr {
private:
    T* m_ptr;
    int* m_refCount;

    void release() {
        if (m_refCount) {
            (*m_refCount)--;
            if (*m_refCount == 0) {
                delete m_ptr;
                delete m_refCount;
                std::cout << "Resource deleted\n";
            }
        }
    }

public:
    // Default constructor
    SharedPtr() : m_ptr(nullptr), m_refCount(nullptr) {}

    // Parameterized constructor
    explicit SharedPtr(T* ptr) : m_ptr(ptr), m_refCount(new int(1)) {}

    // Copy constructor
    SharedPtr(const SharedPtr& other) : m_ptr(other.m_ptr), m_refCount(other.m_refCount) {
        if (m_refCount) {
            ++(*m_refCount);
        }
    }

    // Copy assignment
    SharedPtr& operator=(const SharedPtr& other) {
        if (this != &other) {
            release();
            m_ptr = other.m_ptr;
            m_refCount = other.m_refCount;
            if (m_refCount) {
                ++(*m_refCount);
            }
        }
        return *this;
    }

    // Move constructor
    SharedPtr(SharedPtr&& other) noexcept : m_ptr(other.m_ptr), m_refCount(other.m_refCount) {
        other.m_ptr = nullptr;
        other.m_refCount = nullptr;
    }

    // Move assignment
    SharedPtr& operator=(SharedPtr&& other) noexcept {
        if (this != &other) {
            release();
            m_ptr = other.m_ptr;
            m_refCount = other.m_refCount;
            other.m_ptr = nullptr;
            other.m_refCount = nullptr;
        }
        return *this;
    }

    // Destructor
    ~SharedPtr() {
        release();
    }

    // Get raw pointer
    T* get() const {
        return m_ptr;
    }

    // Dereference operators
    T& operator*() const {
        return *m_ptr;
    }

    T* operator->() const {
        return m_ptr;
    }

    // Use count
    int use_count() const {
        return m_refCount ? *m_refCount : 0;
    }

    // Reset
    void reset(T* ptr = nullptr) {
        release();
        if (ptr) {
            m_ptr = ptr;
            m_refCount = new int(1);
        } else {
            m_ptr = nullptr;
            m_refCount = nullptr;
        }
    }

    // Bool conversion
    explicit operator bool() const {
        return m_ptr != nullptr;
    }
};


struct Test {
    Test(int x) : val(x) {
        std::cout << "Test created\n";
    }
    ~Test() {
        std::cout << "Test destroyed\n";
    }
    int val;
    void show() {
        std::cout << "Value: " << val << "\n";
    }
};

int main() {
    SharedPtr<Test> p1(new Test(100));
    std::cout << "p1 use_count: " << p1.use_count() << "\n";

    {
        SharedPtr<Test> p2 = p1;
        std::cout << "p2 use_count: " << p2.use_count() << "\n";
        p2->show();
    } // p2 goes out of scope

    std::cout << "p1 use_count after p2: " << p1.use_count() << "\n";

    p1.reset();
    std::cout << "p1 use_count after reset: " << p1.use_count() << "\n";

    return 0;
}

Test created
p1 use_count: 1
p2 use_count: 2
Value: 100
Test destroyed
Resource deleted
p1 use_count after p2: 1
Test destroyed
Resource deleted
p1 use_count after reset: 0

Common Follow-up Questions
What's the difference between shared_ptr and unique_ptr?

What are circular references and how to avoid them?

How would you implement weak_ptr?

Can SharedPtr be made thread-safe?

Why use a separate control block in real-world implementations?
