cyclic ref issue 

#include <iostream>
#include <memory>
using namespace std;

class Child;  // forward declaration

class Parent {
public:
    shared_ptr<Child> childlist;
    ~Parent() { cout << "destroy Parent\n"; }
};

class Child {
public:
    // Change this from shared_ptr to weak_ptr:
    shared_ptr<Parent> parentlist;
    ~Child() { cout << "destroy Child\n"; }
};

int main() {
    auto p1 = make_shared<Parent>();
    auto p2 = make_shared<Child>();

    p1->childlist = p2;    
    p2->parentlist = p1;    

}

dry run:

Create p1:
auto p1 = make_shared<Parent>();
A new Parent object is allocated.
p1 is the sole owner, so Parent’s ref‐count = 1.

Create p2:
auto p2 = make_shared<Child>();
A new Child object is allocated.
p2 is the sole owner, so Child’s ref‐count = 1.

Parent takes ownership of Child:
p1->childlist = p2;
childlist is a shared_ptr<Child>, so assigning p2 to it increments the child’s count.
Child’s ref‐count goes from 1 → 2 (owners are p2 and p1->childlist).

Child takes ownership of Parent:
p2->parentlist = p1;
parentlist is also a shared_ptr<Parent>, so assigning p1 to it increments the parent’s count.
Parent’s ref‐count goes from 1 → 2 (owners are p1 and p2->parentlist).

End of main() and scope exit:
First, p1 goes out of scope. That drops Parent’s ref‐count from 2 → 1, but it’s not zero—so Parent is not destroyed.
Next, p2 goes out of scope. That drops Child’s ref‐count from 2 → 1, but it’s not zero—so Child is not destroyed.

**************solution ************
#include <iostream>
#include <memory>
using namespace std;

class Child;  // forward declaration

class Parent {
public:
    shared_ptr<Child> childlist;
    ~Parent() { cout << "destroy Parent\n"; }
};

class Child {
public:
    weak_ptr<Parent> parentlist;   // ← non‑owning
    ~Child()  { cout << "destroy Child\n"; }
};

int main() {
    auto p1 = make_shared<Parent>();   // (1)
    auto p2 = make_shared<Child>();    // (2)

    p1->childlist = p2;                // (3)
    p2->parentlist = p1;               // (4)

}                                       // (5)


Step‑by‑Step Execution & Counts
Create p1:
auto p1 = make_shared<Parent>();
A new Parent object is created.
Parent ref‑count = 1 (owned by p1).

Create p2:
auto p2 = make_shared<Child>();
A new Child object is created.
Child ref‑count = 1 (owned by p2).

Parent takes ownership of Child:
p1->childlist = p2;
childlist is a shared_ptr<Child>, so assigning p2 to it increments the child’s count.
Child ref‑count goes from 1 → 2 (owners: p2 and p1->childlist).

Child holds a weak reference to Parent:
p2->parentlist = p1;
parentlist is a weak_ptr<Parent>, so it does NOT increment the parent’s count.
Parent ref‑count remains 1 (only owned by p1).

End of main() and scope exit:
First, p1 goes out of scope → Parent ref‑count: 1 → 0 → Parent destructor runs, printing destroy Parent.
Inside ~Parent(), its childlist (a shared_ptr) is destroyed, dropping Child ref‑count: 2 → 1.
Then p2 goes out of scope → Child ref‑count: 1 → 0 → Child destructor runs, printing destroy Child.
