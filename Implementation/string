#include <iostream>
#include <cstring>
#include <utility>
#include <stdexcept>

class MyString {
private:
    char* m_data;
    size_t m_length;

public:
    // Default constructor
    MyString() : m_data(nullptr), m_length(0) {}

    // Constructor from C-style string
    MyString(const char* str) {
        if (str) {
            m_length = std::strlen(str);
            m_data = new char[m_length + 1];
            std::strcpy(m_data, str);
        } else {
            m_data = nullptr;
            m_length = 0;
        }
    }

    // Copy constructor (deep copy)
    MyString(const MyString& other) {
        std::cout << "Copy constructor\n";
        if (other.m_data) {
            m_length = other.m_length;
            m_data = new char[m_length + 1];
            std::strcpy(m_data, other.m_data);
        } else {
            m_data = nullptr;
            m_length = 0;
        }
    }

    // Move constructor
    MyString(MyString&& other) noexcept
        : m_data(other.m_data), m_length(other.m_length) {
        std::cout << "Move constructor\n";
        other.m_data = nullptr;
        other.m_length = 0;
    }

    // Copy assignment operator
    MyString& operator=(const MyString& other) {
        std::cout << "Copy assignment\n";
        if (this != &other) {
            delete[] m_data;
            if (other.m_data) {
                m_length = other.m_length;
                m_data = new char[m_length + 1];
                std::strcpy(m_data, other.m_data);
            } else {
                m_data = nullptr;
                m_length = 0;
            }
        }
        return *this;
    }

    // Move assignment operator
    MyString& operator=(MyString&& other) noexcept {
        std::cout << "Move assignment\n";
        if (this != &other) {
            delete[] m_data;
            m_data = other.m_data;
            m_length = other.m_length;
            other.m_data = nullptr;
            other.m_length = 0;
        }
        return *this;
    }

    // Destructor
    ~MyString() {
        delete[] m_data;
    }

    // Accessors
    const char* c_str() const {
        return m_data ? m_data : "";
    }

    size_t size() const {
        return m_length;
    }

    bool empty() const {
        return m_length == 0;
    }

    // Operator[]
    char& operator[](size_t index) {
        if (index >= m_length) throw std::out_of_range("Index out of range");
        return m_data[index];
    }

    const char& operator[](size_t index) const {
        if (index >= m_length) throw std::out_of_range("Index out of range");
        return m_data[index];
    }

    // Stream insertion
    friend std::ostream& operator<<(std::ostream& os, const MyString& str) {
        os << str.c_str();
        return os;
    }
};


int main() {
    MyString s1("Hello");
    MyString s2 = s1;         // Copy constructor
    MyString s3 = std::move(s1); // Move constructor

    std::cout << "s2: " << s2 << "\n";
    std::cout << "s3: " << s3 << "\n";

    MyString s4;
    s4 = s2;                  // Copy assignment
    s4 = MyString("World");   // Move assignment

    std::cout << "s4: " << s4 << "\n";

    std::cout << "s4[0]: " << s4[0] << "\n";
    std::cout << "Length: " << s4.size() << "\n";
}


When presenting this code, be ready to explain:

Why deep copy is needed (because of dynamic allocation).

Why const char* is used as input (for interop with C-style strings).

The Rule of Five and why move constructors improve performance.

Exception safety: no resource leaks, operator[] bounds check.

That this is a minimal example â€” more features (e.g. +=, comparisons) can be added if needed.
