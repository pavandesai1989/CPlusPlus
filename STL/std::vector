vector provides O(1) fast access and dynamic allocation of memory ******

1. dynamic size :
    std::vector solves this: With std::vector, the size of the array can grow or shrink at runtime, allowing you to add or remove elements as needed. This dynamic resizing is essential for many algorithms and applications where data is collected or modified on the fly.

2. Automatic Memory Management
Manual memory management with arrays: In C-style arrays, if you want to dynamically allocate an array of unknown size, you need to manage memory manually using new and delete. This introduces the risk of memory leaks, dangling pointers, or errors in allocation and deallocation.
std::vector handles memory automatically: It internally manages memory allocation and deallocation, ensuring that memory is allocated when the vector grows and properly freed when the vector goes out of scope or is no longer needed.

3. Efficient Resizing and Reallocation   

4. Random Access:
Just like arrays, std::vector provides constant-time random access to its elements via the [] operator or the at() method. This allows efficient access to any element by its index.


Summary: Why We Need std::vector
Dynamic sizing: Can grow or shrink at runtime, making it useful for cases where the number of elements isn't known in advance.
Automatic memory management: Avoids manual memory management errors like memory leaks or buffer overflows.
Random access: Provides constant-time access to elements just like arrays.
Efficient resizing: Handles memory efficiently, with amortized constant-time insertion at the end.
Standard algorithms: Integrates seamlessly with C++ STL algorithms.
Versatile operations: Provides rich methods to add, remove, and modify elements.


Key Features of std::vector
✅ Dynamic Resizing – It grows automatically when needed.
✅ Contiguous Memory Allocation – Just like arrays, elements are stored sequentially.
✅ Fast Access (O(1)) – Accessing elements using [] is constant time.
✅ Efficient Insertions/Deletions (at End) – push_back() and pop_back() are amortized O(1).
✅ Support for Iterators – Works well with range-based loops, algorithms, and iterators.


| Method                  | Return Type              | Purpose / Description                                           | Example Usage                      |
| ----------------------- | ------------------------ | --------------------------------------------------------------- | ---------------------------------- |
| `size()`                | `size_t`                 | Returns number of elements in the vector                        | `v.size()`                         |
| `capacity()`            | `size_t`                 | Returns current allocated storage capacity                      | `v.capacity()`                     |
| `empty()`               | `bool`                   | Checks if vector is empty                                       | `v.empty()`                        |
| `resize(n)`             | `void`                   | Resizes vector to `n` elements (default-initialized if growing) | `v.resize(10)`                     |
| `reserve(n)`            | `void`                   | Increases capacity to at least `n` elements                     | `v.reserve(100)`                   |
| `shrink_to_fit()`       | `void`                   | Requests to reduce capacity to fit size                         | `v.shrink_to_fit()`                |
| `clear()`               | `void`                   | Removes all elements                                            | `v.clear()`                        |
| `push_back(val)`        | `void`                   | Appends `val` to the end                                        | `v.push_back(5)`                   |
| `pop_back()`            | `void`                   | Removes last element                                            | `v.pop_back()`                     |
| `insert(pos, val)`      | `iterator`               | Inserts `val` before `pos`                                      | `v.insert(v.begin()+1, 42)`        |
| `erase(pos)`            | `iterator`               | Removes element at `pos`                                        | `v.erase(v.begin()+2)`             |
| `erase(start, end)`     | `iterator`               | Removes a range of elements                                     | `v.erase(v.begin(), v.begin()+3)`  |
| `assign(n, val)`        | `void`                   | Assigns `n` copies of `val`                                     | `v.assign(5, 100)`                 |
| `swap(other)`           | `void`                   | Swaps contents with another vector                              | `v1.swap(v2)`                      |
| `front()`               | `T&` / `const T&`        | Access first element                                            | `v.front()`                        |
| `back()`                | `T&` / `const T&`        | Access last element                                             | `v.back()`                         |
| `operator[]`            | `T&` / `const T&`        | Direct access without bounds check                              | `v[2]`                             |
| `at(index)`             | `T&` / `const T&`        | Bounds-checked access, throws on error                          | `v.at(2)`                          |
| `data()`                | `T*`                     | Pointer to underlying array                                     | `int* p = v.data()`                |
| `begin()` / `end()`     | `iterator`               | Iterators to first and one-past-last element                    | `for (auto it = v.begin(); ...)`   |
| `cbegin()` / `cend()`   | `const_iterator`         | Const iterators                                                 | `for (auto it = v.cbegin(); ...)`  |
| `rbegin()` / `rend()`   | `reverse_iterator`       | Reverse iterators                                               | `for (auto it = v.rbegin(); ...)`  |
| `crbegin()` / `crend()` | `const_reverse_iterator` | Const reverse iterators                                         | `for (auto it = v.crbegin(); ...)` |
| `emplace(pos, args...)` | `iterator`               | Constructs element in-place at `pos`                            | `v.emplace(v.begin()+1, 50)`       |
| `emplace_back(args...)` | `void`                   | Constructs element in-place at the end                          | `v.emplace_back(42)`               |


shrink_to_fit() in C++
The shrink_to_fit() function is used to reduce the capacity of a dynamic container (like std::vector, std::deque, or std::string) to match its size, potentially releasing unused memory.

When to Use shrink_to_fit
You should use shrink_to_fit() when:
| Scenario                                                                | Why `shrink_to_fit()` Helps                    |
| ----------------------------------------------------------------------- | ---------------------------------------------- |
| ✅ You've removed many elements (via `erase`, `pop_back`, `resize`)      | To **release excess memory**                   |
| ✅ You've cleared the container (`vec.clear()`)                          | To **free capacity** not returned by `clear()` |
| ✅ You've reserved extra capacity with `reserve()` but no longer need it | To **give memory back to the system**          |
| ✅ After swapping/shuffling elements                                     | To **reclaim unused heap memory**              |

clear() in C++ STL containers (like vector, string, deque) removes all elements, but it does not free the memory (capacity remains unchanged).

Should You Use shrink_to_fit() After clear()?
Yes — if your goal is to release unused memory back to the system, then calling shrink_to_fit() after clear() is appropriate.

***************ways to initialize vector*******
// Online C++ compiler to run C++ program online
#include <iostream>
#include <vector>
#include <array>

using namespace std;

int main() 
{
    //Under the hood, the std::vector constructor that takes an std::initializer_list<int> is invoked.
    vector<int> vec= {1,2,3,4,5}; //initializer list 
    
    for(auto ele:vec)
    {
        cout<<ele<<" ";
    }
    cout<<endl;

    //using push_back
    vector<int> vec2;
    vec2.push_back(2);
    vec2.push_back(3);
    vec2.push_back(4);

    for(auto ele:vec2)
    {
        cout<<ele<<" ";
    }
    cout<<endl;


    //with single value
    vector<int> vec3(4,14); //creates 4 elements with all initialized to 14
    for(auto ele:vec3)
    {
        cout<<ele<<" ";
    }
    cout<<endl;

    //initialize using array 
    array<int,4> arr = {7,8,4,6};    
    vector<int> vec4 (arr.begin(),arr.end());

    int arr1[] = {3,4,8,2,5,9,6};
    int n = sizeof(arr1)/sizeof(arr1[0]);
    vector<int> vec5(arr1,arr1+n);
    for(auto ele:vec5)
    {
        cout<<ele<<" ";
    }
    cout<<endl;

    //another vector 
    vector<int> vec6(vec5.begin(),vec5.end());
    for(auto ele:vec6)
    {
        cout<<ele<<" ";
    }

    return 0;
}

*********************************
    
#include <iostream>
#include <vector>
#include <algorithm>  // For std::sort

int main() {
    // 1. Default constructor (Empty vector)
    std::vector<int> vec;

    // 2. push_back() - Add elements to the end of the vector
    vec.push_back(10);
    vec.push_back(20);
    vec.push_back(30);
    
    std::cout << "After push_back: ";
    for (int i : vec) std::cout << i << " ";  // Output: 10 20 30
    std::cout << std::endl;

    // 3. size() - Returns the number of elements
    std::cout << "Size of vector: " << vec.size() << std::endl;  // Output: 3

    // 4. at() - Access elements with bounds checking
    std::cout << "Element at index 1: " << vec.at(1) << std::endl;  // Output: 20

    // 5. [] operator - Access elements without bounds checking
    std::cout << "Element at index 0: " << vec[0] << std::endl;  // Output: 10

    // 6. front() - Get the first element
    std::cout << "First element: " << vec.front() << std::endl;  // Output: 10

    // 7. back() - Get the last element
    std::cout << "Last element: " << vec.back() << std::endl;  // Output: 30

    // 8. insert() - Insert an element at a specific position
    vec.insert(vec.begin() + 1, 15);  // Insert 15 at index 1
    std::cout << "After insert: ";
    for (int i : vec) std::cout << i << " ";  // Output: 10 15 20 30
    std::cout << std::endl;

    // 9. erase() - Remove an element from a specific position
    vec.erase(vec.begin() + 2);  // Erase element at index 2
    std::cout << "After erase: ";
    for (int i : vec) std::cout << i << " ";  // Output: 10 15 30
    std::cout << std::endl;

    // 10. pop_back() - Remove the last element
    vec.pop_back();  // Remove last element (30)
    std::cout << "After pop_back: ";
    for (int i : vec) std::cout << i << " ";  // Output: 10 15
    std::cout << std::endl;

    // 11. clear() - Remove all elements
    vec.clear();
    std::cout << "After clear, size of vector: " << vec.size() << std::endl;  // Output: 0

    // 12. empty() - Check if the vector is empty
    if (vec.empty()) {
        std::cout << "Vector is empty." << std::endl;  // This will be printed
    }

    // 13. resize() - Resize the vector (if growing, new elements are value-initialized)
    vec.resize(5, 100);  // Resize vector to 5 elements, new elements initialized to 100
    std::cout << "After resize: ";
    for (int i : vec) std::cout << i << " ";  // Output: 100 100 100 100 100
    std::cout << std::endl;

    // 14. reserve() - Pre-allocate memory without changing the size
    vec.reserve(10);  // Pre-allocate memory for 10 elements
    std::cout << "Capacity after reserve: " << vec.capacity() << std::endl;

    // 15. sort() - Sorting the vector (using STL algorithm)
    vec = {50, 30, 20, 10, 40};  // Reassign vector values
    std::sort(vec.begin(), vec.end());  // Sort in ascending order
    std::cout << "After sort: ";
    for (int i : vec) std::cout << i << " ";  // Output: 10 20 30 40 50
    std::cout << std::endl;

    return 0;
}
