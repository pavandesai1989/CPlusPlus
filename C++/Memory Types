1. Stack Memory

Definition: Memory allocated automatically for local variables and function calls.

Lifetime: Exists only during the scope of the function/block.

Size: Limited, usually smaller than heap.

Allocation/Deallocation: Automatic (done by compiler).

Example:

void func() {
    int x = 10;  // stored on stack
} // x destroyed automatically


Key Points:

Fast access.

Size must be known at compile time.

Local variables and function parameters live here.

2. Heap Memory (Dynamic Memory)

Definition: Memory allocated at runtime using new/delete in C++ (or malloc/free in C).

Lifetime: Exists until manually freed.

Size: Larger, limited by system memory.

Allocation/Deallocation: Manual.

Example:

int* p = new int(42);  // allocate on heap
delete p;              // free memory


Key Points:

Use when size is unknown at compile time.

Must manage memory to avoid leaks.

Objects survive beyond function scope.

ðŸ”¹ 3. Static/Global Memory

Definition: Memory for global variables, static variables, and constants.

Lifetime: Exists throughout the program execution.

Allocation/Deallocation: Done at program load/unload automatically.

Example:

int globalVar = 100;  // global, stored in static memory

void func() {
    static int counter = 0; // static variable
    counter++;
    cout << counter << endl;
}


Key Points:

Shared across all functions.

Useful for counters or configuration values.

4. Code/Text Segment

Definition: Memory where the executable code of the program is stored.

Characteristics:

Read-only (prevents accidental modification).

Shared among multiple instances of the program.

| Memory Type   | Allocation      | Lifetime       | Example              | Managed by |
| ------------- | --------------- | -------------- | -------------------- | ---------- |
| Stack         | Automatic       | Function scope | `int x;`             | Compiler   |
| Heap          | Dynamic (`new`) | Until `delete` | `int* p = new int;`  | Programmer |
| Static/Global | Static          | Entire program | `static int x;`      | Compiler   |
| Code/Text     | Static          | Entire program | Program instructions | OS         |

+------------------------+  <- High memory addresses
|      Code Segment      |  (Executable instructions)
+------------------------+
|    Static/Global Data  |  (Global variables, static variables)
+------------------------+
|                        |
|        Heap â†‘           |  (Dynamic memory allocated via new/malloc)
|                        |
|                        |
|------------------------|
|                        |
|        Stack â†“          |  (Local variables, function calls)
|                        |
+------------------------+  <- Low memory addresses

Key Points to Explain in Interview

Stack

Stores local variables and function call info (return addresses).

Grows downwards (towards lower memory addresses).

Automatic allocation and deallocation.

Heap

Stores dynamic memory (objects created via new or malloc).

Grows upwards (towards higher memory addresses).

Programmer must manually free memory.

Static/Global Data

Stores global variables and static variables.

Lifetime: entire program execution.

Code Segment

Stores executable instructions.

Usually read-only.

â€œAs you can see, stack grows downward and heap grows upward. If they meet, stack overflow or heap corruption can occur. 
This layout helps in understanding memory allocation, lifetime, and scope of variables in C++.â€

ðŸ”¹ When Can They Meet?
High memory addresses
+------------------------+
|        Code            |
+------------------------+
|   Static / Global      |
+------------------------+
|        Heap â†‘           |
|                        |
|                        |
|------------------------|
|        Stack â†“          |
|                        |
Low memory addresses
The heap grows upward: each new new or malloc pushes the top of the heap to higher addresses.

The stack grows downward: each function call or local variable allocation pushes the stack pointer to lower addresses.

There is a gap between the current top of the heap and the bottom of the stack.

Even though they grow in opposite directions, they share the same virtual address space.


When do they â€œmeetâ€?

Normally: heap top < stack bottom â†’ everything is fine.

If heap grows too much (many large new allocations) and stack grows too much (deep recursion, large local arrays), the top of the heap moves up, and stack pointer moves down.
High addresses
+------------------------+
| Code/Global             |
+------------------------+
| Heap top â†‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   |
| Stack bottom â†“ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ |
+------------------------+
Low addresses

The â€œgapâ€ between heap and stack disappears.

Now, the heap memory can collide with the stack memory, because both occupy the same address space.

Any access beyond this point â†’ segmentation fault or corruption.

Key Takeaways

Stack and heap grow in opposite directions but share the same memory corridor.

They â€œmeetâ€ when the gap between them disappears due to excessive allocation.

This is why stack overflow + heavy heap usage can crash your program.

