Why overload new and delete?

By default, new allocates memory from the heap and calls the constructor, while delete calls the destructor and frees memory.

Sometimes you want custom behavior:

Logging allocations/deallocations

Pool allocation

Debugging memory leaks

"In C++, we can overload new and delete operators to customize memory allocation and deallocation. This is often done at the class level for things like logging, memory pooling, or debugging memory usage."

How to Explain

Allocation:

operator new allocates raw memory before the constructor is called.

Construction:

After memory allocation, the constructor initializes the object.

Deletion:

When delete is called, the destructor runs first, then operator delete frees the memory.

Scope:

Class-level new/delete overrides the global versions only for that class.

Global new/delete are used for other types like int, double, etc.

*****
🔹 Optional Follow-up Mention

"In production, we usually call ::operator new(size) and ::operator delete(ptr) instead of malloc/free to ensure exception safety and proper alignment."


#include <iostream>
using namespace std;

class test
{
private:
int m_x;

public:
test(int a=0):m_x(a)
{

}

void* operator new(size_t sz)
{
    cout<<"calling class new "<<endl;
    return malloc(sz);
}

void operator delete(void* p)
{
    cout<<"calling class delete "<<endl;
    free(p);
}
};

void* operator new(size_t sz)
{
    cout<<"calling global new "<<endl;
    return malloc(sz);
}

void operator delete(void* p)
{
    cout<<"calling global delete "<<endl;
    free(p);
}

int main()
{
   test* p = new test;
   delete p;

   int* p1 = new int;
   delete p1;


    return 0;
}

******IMP*****
::operator new in C++

:: refers to the global namespace.

operator new is the global memory allocation function in C++.

So ::operator new(size) means: “call the default, global new operator provided by C++, not any class-level overload.”

use this instead of malloc *********interview 
Without ::operator new, you might use malloc (like in your demo), but:

malloc doesn’t call constructors

malloc doesn’t guarantee proper C++ alignment

Using ::operator new is safer and standard.

*****BELOW CODE FOR INTERVIEW****
#include <iostream>
using namespace std;

class test
{
private:
    int m_x;

public:
    test(int a = 0) : m_x(a) {}

    // Class-level new
    void* operator new(size_t sz)
    {
        cout << "calling class new " << endl;
        return ::operator new(sz); // use global operator new
    }

    // Class-level delete
    void operator delete(void* p)
    {
        cout << "calling class delete " << endl;
        ::operator delete(p);      // use global operator delete
    }
};

// Global new
void* operator new(size_t sz)
{
    cout << "calling global new " << endl;
    return ::operator new(sz);      // use global operator new
}

// Global delete
void operator delete(void* p)
{
    cout << "calling global delete " << endl;
    ::operator delete(p);           // use global operator delete
}

int main()
{
    test* p = new test;   // calls class-level new
    delete p;             // calls class-level delete

    int* p1 = new int;    // calls global new
    delete p1;            // calls global delete

    return 0;
}
::operator new(sz) allocates memory just like new would normally do.

::operator delete(p) deallocates memory safely.

This version avoids malloc/free, which is safer in C++ because:

Proper alignment is guaranteed

Exceptions are thrown on allocation failure (bad_alloc)





