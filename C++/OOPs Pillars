1. Encapsulation

Definition:

Encapsulation is the wrapping of data (variables) and methods (functions) into a single unit (class).

It hides implementation details from the user.
The goal is to protect the internal state of an object and only allow modification through well-defined interfaces (methods).

Key points:

Achieved using access specifiers: private, protected, public.

Helps protect data and enforce controlled access.

Example:
class Account {
private:
    double balance;  // hidden from outside

public:
    void deposit(double amount) {
        if(amount > 0) balance += amount;
    }

    double getBalance() const { return balance; }
};

Here, balance cannot be accessed directly; only via member functions.

🔹 2. Abstraction

Definition:

Abstraction exposes only necessary details and hides complex implementation.
Abstraction = Only expose what’s necessary, hide how it’s done.
Abstraction means hiding complex details and showing only essential features to the user. In C++, we do this using classes, abstract classes, and interfaces (pure virtual functions).


Focuses on what an object does, not how it does it.
class Shape {
public:
    virtual void draw() = 0;  // pure virtual function
};

class Circle : public Shape {
public:
    void draw() override { cout << "Drawing Circle\n"; }
};
Users only know draw() exists. Implementation is hidden in derived classes.

Feature	Abstraction	Encapsulation
Focus	Hiding implementation logic	Hiding data
Purpose	To show only relevant details to user	To protect the object’s data
Achieved By	Abstract classes, interfaces (pure virtual functions)	Access specifiers (private, public, etc.)
User Perspective	"What an object does"	"How an object is protected"
Example	Driving a car without knowing engine internals	Locking car doors to protect it


3. Inheritance

Definition:

Inheritance allows a class (derived class) to acquire properties and behaviors of another class (base class).

Key points:

Supports code reusability.

Can be public, protected, or private inheritance.
class Vehicle {
public:
    void start() { cout << "Vehicle started\n"; }
};

class Car : public Vehicle {
public:
    void honk() { cout << "Car honks\n"; }
};

int main() {
    Car c;
    c.start();  // inherited
    c.honk();   // own method
}

4. Polymorphism
Type	Meaning
Compile-time polymorphism	Function overloading, operator overloading
Run-time polymorphism	Virtual functions (via inheritance)

Compile-Time Polymorphism: Function call is bound to its definition during compilation.
Runtime Polymorphism: Function call is bound to its definition during runtime.


Definition:

Polymorphism means “many forms.”

In C++, achieved via:

Compile-time: Function overloading, Operator overloading

Run-time: Virtual functions, inheritance

class Animal {
public:
    virtual void speak() { cout << "Animal speaks\n"; }
};

class Dog : public Animal {
public:
    void speak() override { cout << "Dog barks\n"; }
};

int main() {
    Animal* a = new Dog();
    a->speak();  // calls Dog’s speak() -> run-time polymorphism
    delete a;
}


Compile-time polymorphism example:
class Math {
public:
    int add(int a, int b) { return a+b; }
    double add(double a, double b) { return a+b; } // function overloading
};

Explain with simple examples, like a Vehicle/Car or Animal/Dog.

Mention why each principle is useful:

Encapsulation → data protection

Abstraction → simplicity

Inheritance → code reuse

Polymorphism → flexibility/extensibility

