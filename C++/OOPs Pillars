1. Encapsulation

Definition:

Encapsulation is the wrapping of data (variables) and methods (functions) into a single unit (class).

It hides implementation details from the user.

Key points:

Achieved using access specifiers: private, protected, public.

Helps protect data and enforce controlled access.

Example:
class Account {
private:
    double balance;  // hidden from outside

public:
    void deposit(double amount) {
        if(amount > 0) balance += amount;
    }

    double getBalance() const { return balance; }
};

Here, balance cannot be accessed directly; only via member functions.

🔹 2. Abstraction

Definition:

Abstraction exposes only necessary details and hides complex implementation.

Focuses on what an object does, not how it does it.
class Shape {
public:
    virtual void draw() = 0;  // pure virtual function
};

class Circle : public Shape {
public:
    void draw() override { cout << "Drawing Circle\n"; }
};
Users only know draw() exists. Implementation is hidden in derived classes.


3. Inheritance

Definition:

Inheritance allows a class (derived class) to acquire properties and behaviors of another class (base class).

Key points:

Supports code reusability.

Can be public, protected, or private inheritance.
class Vehicle {
public:
    void start() { cout << "Vehicle started\n"; }
};

class Car : public Vehicle {
public:
    void honk() { cout << "Car honks\n"; }
};

int main() {
    Car c;
    c.start();  // inherited
    c.honk();   // own method
}

4. Polymorphism

Definition:

Polymorphism means “many forms.”

In C++, achieved via:

Compile-time: Function overloading, Operator overloading

Run-time: Virtual functions, inheritance

class Animal {
public:
    virtual void speak() { cout << "Animal speaks\n"; }
};

class Dog : public Animal {
public:
    void speak() override { cout << "Dog barks\n"; }
};

int main() {
    Animal* a = new Dog();
    a->speak();  // calls Dog’s speak() -> run-time polymorphism
    delete a;
}


Compile-time polymorphism example:
class Math {
public:
    int add(int a, int b) { return a+b; }
    double add(double a, double b) { return a+b; } // function overloading
};

Explain with simple examples, like a Vehicle/Car or Animal/Dog.

Mention why each principle is useful:

Encapsulation → data protection

Abstraction → simplicity

Inheritance → code reuse

Polymorphism → flexibility/extensibility

